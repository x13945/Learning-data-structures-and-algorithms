## 排序算法

排序算法是日常十分常见的算法，其算法也有很多种。下面大致说几种



## 快速排序

实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组的左边，比选择的数字大的数字移到数组的右边。

分区算法的思路：

1. 找到分区中的任意一个下标位置，一般可以用随机算法生成
2. 交换随机下标和分区最右端的元素
3. 定义一个下标`small`，用来记录比最右端元素小的元素的下标。初始化为分区开头下标`start-1`
4. 定义一个从分区开头开始遍历的下标，开始遍历分区
5. 如果遇到比最右端元素大的，则和`small`下标右边的元素交换
6. 最终`[start, small]`范围内都是比最右侧元素小的元素
7. 把最右侧元素和`small+1`下标进行交换，形成当初选定随机元素左侧都比随机元素小，右侧都比随机元素大的序列

代码在这里:[快排](./QuickSort.java)

## 冒泡排序

所谓冒泡每次比较相邻的两个数据，并且把大的向后移动。这样，经过比较一个循环，就会把数列中最大的数移动到数列的尾部。下一次比较多时候，避开 最后一个数据即可。

思路：

1. 定义一个长度为数组长度的循环
2. 定义一个内循环用于比较交换两个相邻的数字，每次比较相邻的两个元素

代码在这里:[冒泡](./BubbleSort.java)

## 插入排序

插入排序的思想是选取为排序区间的数字，依次插入到已排序的区间中，并保证插入后的已排序区间依然是有序状态。

思路：

1. 选取第一个元素作为已排序空间
2. 第二个元素与前一个元素比较，如果大于第一个元素，就不动，并把排序区间扩大到第二个元素，如果小于前一个元素，就把前一个元素向后移动，把第二个元素放到第一个元素前。
3. 循环第二步，直到所有未排序的元素用光为止。

代码在这里：[插入排序](./InsertionSort.java)

> 这里插一句，虽然插入和冒泡排序的空间复杂度都是O(1)，时间复杂度都是O(n²)，但是冒泡排序中的关键代码是交换，有三个赋值语句，而插入是一个赋值语句，因此实际上插入排序比冒泡效率高

## 选择排序

选择排序和插入排序有点类似，也是把数列分为已排序区间和未排序区间。依次在为排序区间中找到最小的元素，插入已排序区间的尾部。



1. 已排序区间初始长度是0
2. 找到未排序区间中最小值所在的下标
3. 把最小值下标和已排序区间长度相等的下标位置交换数值


代码在这里：[选择排序](./SelectionSort.java)
